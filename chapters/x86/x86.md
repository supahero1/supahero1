CPU, or processor, is a piece of hardware designed to execute instructions. An instruction is the simplest non-divisible operation from the perspective of a programmer. There are a lot of instructions, and a collection of instructions for a given architecture is called an instruction set. An architecture is a concept of design, it's like a blueprint to follow, a set of things you have to provide, but you have wiggle room as to how you're gonna implement the things. Examples are x86 and ARM.

All processors can be divided into RISC (Reduced Instruction Set Computer) and CISC (Complex Instruction Set Computer). RISC architectures often feature fixed-size instruction width (the amount of physical space taken by one instruction is constant, or sometimes "almost constant") and limited instruction set size that only contains the necessities that you can use to create something more complex. ARM is a RISC architecture used in mobile devices due to its power efficiency. CISC on the other hand features everything but that. The instruction set is very large, containing instructions nobody is probably ever going to use, with varying width and often different width for the same instruction used in a different, specific context. x86 is a CISC architecture, used in Intel and AMD processors. It's most commonly used in desktop computers or laptops for its fast execution speeds.

It's up to debate whether or not CISC really is faster than RISC. In reality, even though CISC instructions are complex and sometimes feature multiple stages and can span hundreds or thousands of CPU cycles, internally they are broken down to simpler RISC-like steps that compose the complex instruction. Additionally, CISC has been funded by enormous companies since decades now, pumping loads of money into the optimization process of CISC CPUs. RISC processors have never had that money flow, and thus they aren't necessarily as optimized as CISC is nowadays.

A CPU cycle is one "tick" of a CPU. A CPU is a synchronous logic circuit that has a clock that steers it. One tick of that clock is one cycle. Only on rare occassions however do instructions complete execution in one cycle. If you have a 1GHz CPU, that means that one cycle is completed every nanosecond. Sounds ridiculously fast, and it is, but nowadays CPUs are hardly performant, because they are actually not the bottleneck in high speed apps - memory is. More on that... perhaps later.

You will be learning CISC only. Once you know CISC, it will be easy to learn RISC by yourself, with the [RARS](https://github.com/TheThirdOne/rars) emulator or other, if you will have the need to. The same goes for other languages in the future. I might be mentioning other ones, but I will only teach the ones that are necessary for your development. Languages only differ by syntax. Programming rules stay the same. Once you know the rules, learning a new language will be as simple as getting used to the new syntax, new functions, or instructions in this case.

First, you need `nasm`. Get it via terminal with `sudo apt install nasm`. It's an assembler, which is a program that takes the text representation of x86 instructions and translates it to the binary format that is recognized by x86 CPUs.

Note that there are many different "formats" of x86 instructions written as text. There's Intel, AT&T, NASM, to list some. You will be learning the NASM syntax, which is similar to Intel's. You can read more about the distinction between x86 formats [here](https://en.m.wikipedia.org/wiki/X86_assembly_language#Syntax).

When talking about processors, a `word` specifies data of the natural width that the processor is made to handle. Nowadays that width is almost certainly 64 bits, or 8 bytes. CPUs are able to handle smaller widths too, but this is the one that it deals with efficiently, and is often the width of its registers as well. However, that word has also rooted deep into assembly language itself back when it was first being used. That's why when talking about assembly specifically, a word is always 16 bits, which was the word size back then. A byte is 8 bits (it's not a universal truth, there have been CPUs with 7 bits for a byte, but extremely rare to differ from 8 nowadays), a word is 16 bits, a dword (double word) is 32 bits, qword (quad word) is 64 bits. You will be using this wording later on when specifying data size.

A CPU internally is composed of a lot of different sections and components working together. Registers are a notable mention. They are the fastest memory earth has to offer, quite literally. Registers are small, usually having width of a CPU word, and are sitting right inside the CPU, which is what makes them so fast, as they are connected directly to all the components steering them, which also minimizes the distance. x86 and its extensions name all the registers that a CPU is supposed to have:

![registers](https://pbs.twimg.com/media/EhJKmJyUYAARscc?format=png&name=large)

Note that some of these registers are only available if your CPU is compatible with an extension defining them. For instance, AVX2 would give you access to all of the YMM registers.

If a register is included in a different register, it means it's actually the same register, but accessing it via a different name exposes a different portion of it. For instance, even though ZMM registers are gigantic, often times you won't need their entire width for operations, which is why you would restrict yourself to YMM or XMM.

In x86, for historic reasons, some registers have special meanings or purposes. Some registers are also used involuntarily as instruction output if the output is too big, like in the case of integer division instruction, which always stores the remainder in DX, and you can't specify otherwise.

[←](../actual_env/actual_env.md) | [→](../x86_coding/x86_coding.md)
